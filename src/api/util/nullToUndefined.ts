import * as _ from 'lodash';

export function isObject(value: any): value is object {
  return _.isObject(value);
}

type Diff<T, U> = T extends U ? never : T;

export type NullToUndefined<T> = T extends object ? { [P in keyof T]: NullToUndefined<T[P]> } : Diff<T, null>;

// TODO: accept optional / null value, return undefined then

/**
 * Remove null values and put them as undefined instead.
 * Optional types generated by GraphQl accept both undefined and null, and sometimes null values are not accepted internally for a field
 * E.g.: an update payload type, where almost all fields are optional on the API but none actually nullable.
 * @param object object with nullable fields
 */
export function nullToUndefined<T extends object>(object: T): NullToUndefined<T> {
  let objectWithoutNullValues: any = {};
  for (const key of Object.keys(object) as (keyof T)[]) {
    const value = object[key];
    if (Array.isArray(value)) {
      objectWithoutNullValues[key] = value.map(element => {
        return isObject(element) ? nullToUndefined(element) : element;
      });
    } else if (isObject(value)) {
      const objectValue = value;
      objectWithoutNullValues[key] = nullToUndefined(objectValue);
    } else {
      objectWithoutNullValues[key] = value === null ? undefined : value;
    }
  }
  return objectWithoutNullValues;
}

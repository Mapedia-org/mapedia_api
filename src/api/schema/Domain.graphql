type Domain {
  _id: String!
  name: String!
  key: String!
  description: String
  concepts(options: DomainConceptsOptions!): DomainConceptsResults
  resources(options: DomainResourcesOptions!): DomainResourcesResults
  subDomains: [DomainBelongsToDomainItem!]
  parentDomains: [DomainBelongsToDomainItem!]
}

# Domain concepts
enum DomainConceptSortingEntities {
  concept
  relationship
}

enum DomainConceptSortingFields {
  _id
  index
}

input DomainConceptSortingOptions {
  entity: DomainConceptSortingEntities!
  field: DomainConceptSortingFields!
  direction: SortingDirection!
}

input DomainConceptsOptions {
  pagination: PaginationOptions
  sorting: DomainConceptSortingOptions
}

type DomainConceptsItem {
  concept: Concept!
  relationship: ConceptBelongsToDomain!
}

type DomainConceptsResults {
  items: [DomainConceptsItem!]!
}

type DomainBelongsToDomainItem {
  domain: Domain!
  relationship: DomainBelongsToDomain!
}

# Domain resources
enum DomainResourcesSortingType {
  recommended
  newest
}

input DomainResourcesFilterOptions {
  resourceTypeIn: [ResourceType!]
  consumedByUser: Boolean
}

input DomainResourcesOptions {
  sortingType: DomainResourcesSortingType!
  # pagination: PaginationOptions! # not required yet
  query: String
  filter: DomainResourcesFilterOptions
}

type DomainResourcesResults {
  items: [Resource!]!
}

input SearchDomainsOptions {
  query: String
  pagination: PaginationOptions!
}

type SearchDomainsResult {
  items: [Domain!]!
}

input CreateDomainPayload {
  name: String!
  key: String!
  description: String
}

input UpdateDomainPayload {
  name: String
  key: String
  description: String
}

type DeleteDomainResponse {
  _id: String!
  success: Boolean!
}

type Query {
  searchDomains(options: SearchDomainsOptions!): SearchDomainsResult!
  getDomainByKey(key: String!): Domain!
}

type Mutation {
  createDomain(payload: CreateDomainPayload!): Domain!
  updateDomain(id: String!, payload: UpdateDomainPayload!): Domain!
  deleteDomain(id: String!): DeleteDomainResponse!
}
